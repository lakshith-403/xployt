import { Quark, QuarkFunction as $ } from '@ui_lib/quark';
import { View, ViewHandler } from '@ui_lib/view';
import './VulnerabilityReport.scss';
import {CACHE_STORE} from '@data/cache';
import {Button, ButtonType} from "@components/button/base";
import {BasicInfoSection} from './components/basicInfo';
import {ProofOfConceptSection} from './components/proofOfConcept';
import {Project, ProjectCache} from "@data/common/cache/project.cache";
import {validateField} from "@components/multistepForm/validationUtils";
import {
    ReportAttachment,
    VulnerabilityReport,
    VulnerabilityReportCache
} from "@data/common/cache/vulnerabilityReport.cache";
import {router} from "@ui_lib/router";
import {User} from "@data/user";
import {modalAlertOnlyOK} from "@main";
import ModalManager, {setContent } from '@/components/ModalManager/ModalManager';

export interface formObject {
    vulnerabilityType: string;
    severity: string;
    reportTitle: string;
    description: string;
    steps: {
        id?: string[];
        description: string;
        attachments: string[];
    }[];
    agreement: boolean;
}

export interface validation {
  result: boolean;
  message: string;
}

export class FieldErrorMessage {
  private message: string;
  private validation = true;

  constructor(message: string) {
    this.message = message;
  }

  render(q: Quark): void {
    this.message && $(q, 'div', 'error-message', {}, this.message.replace(/[^a-zA-Z0-9 ]/g, ''));
  }
}

export function handleInputChange(event: Event, formObject: any, formObjectKey: string, validationType: string, inputContainer: HTMLElement): void {
  const value = (event.target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement).value;
  const validation = validateField(formObjectKey, value, validationType);

  if (validation.result) {
    formObject[formObjectKey] = value;
    console.log('Valid input:', formObject[formObjectKey]);
    const error = inputContainer.querySelector('.error-message');
    if (error) {
      error.remove();
    }
      console.log(formObject);
  } else {
    if (!inputContainer.querySelector('.error-message')) {
      new FieldErrorMessage(validation.message).render(inputContainer);
    }
  }
}

export class VulnerabilityReportFormView extends View {
    protected projectId: string;
    protected vulnerabilityReportCache: VulnerabilityReportCache;
    protected projectCache: ProjectCache;
    protected ProjectInformation: Project | null = null;
    protected severityLevels: Array<string[]> = [];
    protected formObject: formObject;
    protected files: File[][] = [];
    protected submitButton = new Button({
        label: 'Submit Report',
        type: ButtonType.PRIMARY,
        onClick: async (e: Event) => {
            e.preventDefault();
            e.stopPropagation();
            await this.handleSubmit();
        }
    });
    protected agreementCheckbox!: HTMLInputElement;
    protected agreementOnChange!: (event: Event) => void;
    private user!: User

    constructor(params: { projectId: string }) {
        super(params);
        this.projectId = params.projectId;
        this.projectCache = CACHE_STORE.getProject(this.projectId);
        this.vulnerabilityReportCache = CACHE_STORE.getVulnerabilityReport('');

        this.formObject = {
            vulnerabilityType: "",
            severity: "Pending",
            reportTitle: "",
            description: "",
            steps: [],
            agreement: false
        };
        this.submitButton.disabled = true;
    }

    protected async loadProjectData(): Promise<void> {
        try {
            this.ProjectInformation = await this.projectCache.load() as Project;
            this.severityLevels = await this.projectCache.getProjectSeverityLevels(this.projectId);
            this.user = await CACHE_STORE.getUser().get();
        } catch (error) {
            console.error('Failed to load project data:', error);
        }
    }

    protected async prepareReportData():  Promise<VulnerabilityReport> {
        const user = await CACHE_STORE.getUser().get();
      console.log('User:', user);

        const attachments: ReportAttachment[][] = this.files.map((fileArray) =>
            fileArray.map((file) => {
                const id = crypto.randomUUID();
              console.log('File:', file);
                return {
                    id,
                    name: file.name,
                    url: `${id}.${file.name.split('.').pop()}`
                };
            })
        );

        return {
            projectId: this.projectId,
            hackerId: user.id,
            status: 'Pending',
            severity: this.formObject.severity,
            vulnerabilityType: this.formObject.vulnerabilityType,
            title: this.formObject.reportTitle,
            description: this.formObject.description,
            steps: this.formObject.steps.map((step, index) => ({
                stepNumber: String(index + 1).padStart(2, '0'),
                description: step.description,
                attachments: attachments[index] || []
            })),
            createdAt: new Date().toISOString()
        };
    }

    protected async handleSubmit(): Promise<void> {
        const missingFields = this.validateFormFields();

        if (missingFields.length > 0) {
            this.showErrorModal("Submission Error", missingFields.join("\n"));
            return;
        }

        try {
            const report = await this.prepareReportData();
          console.log("Prepared report data:", report);
            const selectedFiles = this.files.flat();
          console.log("Selected files:", selectedFiles);
            const submittedReport = await this.vulnerabilityReportCache.createReport(report, selectedFiles);
          console.log("Submitted report:", submittedReport);

            console.log("Report submitted successfully:", submittedReport);
            router.navigateTo(`/reports/vulnerability/${submittedReport.projectId}/${submittedReport.reportId}`);
        } catch (error) {
            console.error("Error submitting report:", error);
            this.showErrorModal("Submission Error", "An error occurred while submitting the report. Please try again.");
        }
    }

    private validateFormFields(): string[] {
        const missingFields: string[] = [];

        if (!this.formObject.vulnerabilityType) missingFields.push("Vulnerability Type is required.");
        if (this.formObject.severity === "Pending") missingFields.push("Severity must be selected.");
        if (!this.formObject.reportTitle) missingFields.push("Report Title is required.");
        if (!this.formObject.description) missingFields.push("Description is required.");
        if (this.formObject.steps.length === 0) missingFields.push("At least one step is required.");
        if (!this.formObject.agreement) missingFields.push("You must agree to the terms and conditions.");

        return missingFields;
    }

    private showErrorModal(title: string, message: string): void {
        setContent(modalAlertOnlyOK, {
            ".modal-title": title,
            ".modal-message": message,
        });
        ModalManager.show("alertOnlyOK", modalAlertOnlyOK);
    }

  async render(q: Quark): Promise<void> {
    const waiting = $(q, 'div', 'loading-screen', {}, (q) => {
      $(q, 'div', 'spinner', {});
    });

    await this.loadProjectData();
    waiting.innerHTML = '';
    waiting.remove();

    if (this.user.type !== 'Hacker') {
        $(q, 'div', 'error-message', {}, 'You are not authorized to create a report.');
        return;
    }

    if(this.ProjectInformation?.state === 'Closed') {
        $(q, 'div', 'error-message', {}, 'This project is closed. You cannot create a report.');
        return;
    }

    $(q, 'div', 'vulnerability-report hacker', {}, (q) => {
      $(q, 'h2', 'section-subtitle', {}, `#${this.projectId} ${this.ProjectInformation?.title}`);
      $(q, 'h1', 'section-title', {}, 'Vulnerability Report');
      $(q, 'form', '', {}, (q) => {
        new BasicInfoSection(this.formObject, this.severityLevels).render(q);
        new ProofOfConceptSection(this.formObject, this.files).render(q);

              $(q, 'div', 'form-section agreement', {}, (q) => {
                  $(q, 'span', 'row', {}, (q) => {
                      this.agreementCheckbox = $(q, 'input', '', {type: 'checkbox'}) as HTMLInputElement;

                      this.agreementCheckbox.addEventListener('change', (event: Event) => {
                          this.formObject.agreement = (event.target as HTMLInputElement).checked;
                          this.submitButton.disabled = !this.formObject.agreement;
                          const error = q.parentElement?.querySelector('.agreement-error');
                          if (this.formObject.agreement && error) error.remove();
                      });

                      $(q, 'p', '', {for: 'agreement-checkbox'},
                          ' I hereby confirm that I have diligently submitted all findings and have not caused any adverse effects on the client organisation.'
                      );
                  });
              });
          this.submitButton.render(q);
          this.submitButton.disabled = !this.formObject.agreement;
      });
    });
  }

  protected shouldRenderBreadcrumbs(): boolean {
    return true;
  }

  protected setupBreadcrumbs(params: { projectId: string; reportId: string }): void {
    this.breadcrumbs?.clearBreadcrumbs();
    this.breadcrumbs?.addBreadcrumb({
      label: `Projects`,
      link: `/projects`,
    });
    this.breadcrumbs?.addBreadcrumb({
      label: `Project #${params.projectId}`,
      link: `/projects/${params.projectId}`,
    });
    this.breadcrumbs?.addBreadcrumb({
      label: `Create Report`,
      link: `/hacker/new-report/${params.projectId}`,
    });
  }
}

export const vulnReportViewHandler = new ViewHandler(
    '/new-report/{projectId}',
    VulnerabilityReportFormView
);
