import {Quark, QuarkFunction as $} from '@ui_lib/quark';
import {View, ViewHandler} from '@ui_lib/view';
import './VulnerabilityReport.scss';
import {HackerProjects } from '@data/hacker/cache/hacker.projects';
import {CACHE_STORE} from '@data/cache';
import {Button, ButtonType} from "@components/button/base";
import { BasicInfoSection } from './components/basicInfo';
import { ProofOfConceptSection } from './components/proofOfConcept';
import {Project, ProjectCache} from "@data/common/cache/project.cache";
import {validateField} from "@components/multistepForm/validationUtils";
import {ReportAttachment, VulnerabilityReport} from "@data/common/cache/vulnerabilityReport.cache";
import * as crypto from "node:crypto";

export interface formObject {
    vulnerabilityType: string;
    severity: string;
    reportTitle: string;
    description: string;
    steps: {
        description: string;
        attachments: string[];
    }[];
    testDate: string;
    agreement: boolean;
}

export interface validation {
    result: boolean;
    message: string;
}

export class FieldErrorMessage {
    private message: string;
    private validation = true;

    constructor(message: string) {
        this.message = message;
    }

    render(q: Quark): void {
        this.message && $(q, 'div', 'error-message', {}, this.message.replace(/[^a-zA-Z0-9 ]/g, ''));
    }

}

export function handleInputChange(
    event: Event,
    formObject: any,
    formObjectKey: string,
    validationType: string,
    inputContainer: HTMLElement
): void {
    const value = (event.target as HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement).value;
    const validation = validateField(formObjectKey, value, validationType);

    if (validation.result) {
        formObject[formObjectKey] = value;
        console.log('Valid input:', formObject[formObjectKey]);
        const error = inputContainer.querySelector('.error-message');
        if (error) {
            error.remove();
        }
    } else {
        if (!inputContainer.querySelector('.error-message')) {
            new FieldErrorMessage(validation.message).render(inputContainer);
        }
    }
}

export class VulnerabilityReportFormView extends View {
    private projectId: string;
    private projectCache: ProjectCache;
    private ProjectInformation: Project | {} = {};
    private readonly formObject: formObject;
    private files: File[][] = [];
    private submitButton: Button;

    constructor(params: { projectId: string }, formData?: formObject) {
        super(params);
        this.projectId = params.projectId;
        this.projectCache = CACHE_STORE.getProject(this.projectId);
        this.formObject = formData || {
            vulnerabilityType: '',
            severity: '',
            reportTitle: '',
            description: '',
            steps: [],
            testDate: '',
            agreement: false
        };
        this.submitButton = new Button({
            label: 'Submit Report',
            type: ButtonType.PRIMARY,
            onClick: (e: Event) => {
                e.preventDefault();
                this.handleSubmit();
            }
        });
        console.log('params: ', params);
    }

    private async loadProjectData(): Promise<void> {
        try {
            this.ProjectInformation = await this.projectCache.get(false, this.projectId) as Project;
        } catch (error) {
            console.error('Failed to load project data:', error);
        }
    }

    private async handleSubmit(): Promise<void> {
        const user = await CACHE_STORE.getUser().get();
        console.log(this.files)

        let selectedFiles: File[] = this.files.flat();

        let attachments: ReportAttachment[][] = this.files.map((fileArray) =>
            fileArray.map((file) => ({
                id: crypto.randomUUID(),
                name: file.name,
                url: ''
            }))
        );
        for (let i = 0; i < attachments.length; i++) {
            for (let j = 0; j < attachments[i].length; j++) {
                const attachment = attachments[i][j];
                attachments[i][j].url = attachment.id + '.' + attachment.name.split('.').pop();
            }
        }
        console.log(attachments)

        const report: VulnerabilityReport = {
            projectId: this.projectId,
            hackerId: user.id,
            severity: this.formObject.severity,
            vulnerabilityType: this.formObject.vulnerabilityType,
            title: this.formObject.reportTitle,
            description: this.formObject.description,
            steps: this.formObject.steps.map((step, index) => ({
                stepNumber: String(index + 1).padStart(2, '0'),
                description: step.description,
                attachments: attachments[index]
            })),
            testDate: this.formObject.testDate,
            createdAt: new Date().toISOString(),
        }

    }

    async render(q: Quark): Promise<void> {
        const waiting = $(q, 'div', 'loading-screen', {}, (q) => {
            $(q, 'div', 'spinner', {});
        });

        await this.loadProjectData();
        waiting.innerHTML = '';
        waiting.remove();

        $(q, 'div', 'vulnerability-report hacker', {}, (q) => {
            $(q, 'h2', 'section-subtitle', {}, `#${this.projectId} ${(this.ProjectInformation as HackerProjects).title}`);
            $(q, 'h1', 'section-title', {}, "Vulnerability Report");
            $(q, 'form', '', {}, (q) => {
                new BasicInfoSection(this.formObject).render(q);
                new ProofOfConceptSection(this.formObject, this.files).render(q);
                this.submitButton.render(q)
            });
        });
    }
}

export const vulnReportViewHandler = new ViewHandler(
    '/new-report/{reportId}',
    VulnerabilityReportFormView
);
